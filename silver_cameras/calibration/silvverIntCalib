#!/usr/bin/env python
#

from optparse import OptionParser
from opencv.cv import *
from opencv.highgui import *
import sys
from glob import glob

class ImagesSource:
    def __init__(self, image_files):
        self._images_path = image_files

    def get_images(self):
        for path in self._images_path:
            if path.endswith(('.jpg', '.ppm', '.png')):
                yield cvLoadImage(path, CV_LOAD_IMAGE_COLOR)

description = "Receive a serie of images or videos with a checkerboard as input, and outputs the intrinsic calibration of camera which grab that images."
usage="%prog [options] board_width board_height square_width input_files..."
parser = OptionParser(usage=usage, description=description,
                      version="%prog 0.1")
parser.add_option("-i", "--show-images", action="store_true",
                  dest="show_images", default=False,
                  help="Show images when finding corners on input, and\
                        compare the distorted images with the undistorted.")
parser.add_option("-x", "--save-xml", action="store_true",
                  dest="save_xml", default=False,
                  help="Save an opencv xml for distortion and intrinsic\
                        values.")
parser.add_option("-m", "--maximum", type="int", dest="n_boards",
                  help="How many boards will be analyzed")

(options, args) = parser.parse_args()

# Number of squares in horizontal
board_w = int(args[0])

# Number of squares in vertical
board_h = int(args[1])

square_width = int(args[2])

source = ImagesSource(args[2:])

board_n = board_w * board_h
board_sz = cvSize(board_w, board_h)

image_points      = cvCreateMat(options.n_boards*board_n,2,CV_32FC1)
object_points     = cvCreateMat(options.n_boards*board_n,3,CV_32FC1)

point_counts      = cvCreateMat(options.n_boards,1,CV_32SC1)

intrinsic_matrix  = cvCreateMat(3,3,CV_32FC1)
distortion_coeffs = cvCreateMat(4,1,CV_32FC1)

corners           = []

successes = 0
step = 0
frame = 0

# gray_image = cvCreateImage(cvGetSize(image),8,1); # subpixel
# bin_image  = cvCreateImage(cvGetSize(image),8,1);
gray_image = cvCreateImage(cvSize(640, 480),8,1); # subpixel
bin_image  = cvCreateImage(cvSize(640, 480),8,1);

corner_count = 0

if options.show_images:
    cvNamedWindow("Calibration")

# CAPTURE CORNER VIEWS LOOP UNTIL WE'VE GOT n_boards
# SUCCESSFUL CAPTURES (ALL CORNERS ON THE BOARD ARE FOUND)
# while successes < n_boards:
for image in source.get_images():

    #Find chessboard corners:

    cvCvtColor(image, gray_image, CV_BGR2GRAY)

    cvAdaptiveThreshold(gray_image, bin_image, 128.0,
                        CV_ADAPTIVE_THRESH_MEAN_C, CV_THRESH_BINARY, 21, 8);

    (found, corners) = cvFindChessboardCorners(bin_image, board_sz,
                                               CV_CALIB_CB_NORMALIZE_IMAGE)

    #Draw it
    cvDrawChessboardCorners(image, board_sz, corners, found)

    if options.show_images:
        cvShowImage("Calibration", image );

    # If we got a good board, add it to our data
    if found:
        offset = successes*board_n;
        #Get Subpixel accuracy on those corners
        cvFindCornerSubPix(bin_image, corners, cvSize(5, 5), cvSize(-1,-1),
                           cvTermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,
                                          1000, 0.0001))

        step = successes*board_n;
        for i in range(board_n):
            image_points[offset+i][0] = corners[i].x
            image_points[offset+i][1] = corners[i].y
            object_points[offset+i][0] = i/board_w * square_width
            object_points[offset+i][1] = i%board_w * square_width
            object_points[offset+i][2] = 0.0

        point_counts[successes] = board_n

        successes += 1


    # Handle pause/unpause and ESC
    c = cvWaitKey(15)
    # if c == 'p':
    #     c = 0
    #     while c != 'p' and c != 27:
    #           c = cvWaitKey(250)

    # if c == 27:
    #     exit

#ALLOCATE MATRICES ACCORDING TO HOW MANY CHESSBOARDS FOUND
object_points2 = cvCreateMat(successes*board_n,3,CV_32FC1);
image_points2 = cvCreateMat(successes*board_n,2,CV_32FC1);
point_counts2 = cvCreateMat(successes,1,CV_32SC1);

#TRANSFER THE POINTS INTO THE CORRECT SIZE MATRICES
#Below, we write out the details in the next two loops. We could
#instead have written:
#image_points->rows = object_points->rows = \
#successes*board_n; point_counts->rows = successes;
for i in range(successes*board_n):
    image_points2[i][0] = image_points[i][0]
    image_points2[i][1] = image_points[i][1]
    object_points2[i][0] = object_points[i][0]
    object_points2[i][1] = object_points[i][1]
    object_points2[i][2] = object_points[i][2]

for i in range(successes):
    point_counts2[i] = point_counts[i]

cvReleaseMat(object_points)
cvReleaseMat(image_points)
cvReleaseMat(point_counts)

# At this point we have all of the chessboard corners we need.
# Initialize the intrinsic matrix such that the two focal
# lengths have a ratio of 1.0
intrinsic_matrix[0][0] = 1.0
intrinsic_matrix[1][1] = 1.0

cvCalibrateCamera2(
    object_points2, image_points2,
    point_counts2, cvGetSize( image ),
    intrinsic_matrix, distortion_coeffs)

# ---------------------------------------------------- Outputs the results

print("focal_length = {" + str(intrinsic_matrix[0][0]) + ", "
      + str(intrinsic_matrix[1][1]) + "},")
print("principal_point = {" + str(intrinsic_matrix[0][2]) + ", "
      + str(intrinsic_matrix[1][2]) + "},")
print("radial_coef = {" + str(distortion_coeffs[0]) + ", "
      + str(distortion_coeffs[1]) + "},")
print("tangential_coef = {" + str(distortion_coeffs[2]) + ", "
      + str(distortion_coeffs[3]) + "},")

if options.save_xml:
    cvSave("Intrinsics.xml",intrinsic_matrix);
    cvSave("Distortion.xml",distortion_coeffs);

if options.show_images:
    mapx = cvCreateImage( cvSize(640,480), IPL_DEPTH_32F, 1 )
    mapy = cvCreateImage( cvSize(640,480), IPL_DEPTH_32F, 1 )

    cvInitUndistortMap(intrinsic_matrix, distortion_coeffs, mapx, mapy)

    cvNamedWindow( "Undistort" );
    for image in source.get_images():
        t = cvCreateImage( cvSize(640,480), 8, 3 )
        cvShowImage( "Calibration", image ) # Show raw image
        cvRemap( image, t, mapx, mapy )     # Undistort image
        cvShowImage("Undistort", t)     # Show corrected image

        c = cvWaitKey(0)
